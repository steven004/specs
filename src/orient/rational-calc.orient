FastPorep:
  Utils:
    b_in_gb = (1024 * 1024 * 1024)
    secs_in_month = (24 * 30 * 60 * 60)

  Graph:
    sector_size = sector_size_gb * b_in_gb

    nodes = sector_size / node_size 
    node_size_gb = node_size / b_in_gb 
    node_hash_size_gb = drg_parents * node_size_gb
    node_hash_size = node_hash_size_gb * b_in_gb

    challenge_periods_per_month = secs_in_month / polling_time

    window_size = window_size_mb * 1024 * 1024
    windows = sector_size / window_size
    window_nodes = nodes / windows

  Rig:
    rig_storage_min = rig_storage_min_tb * 1024 * 1024 * 1024 * 1024
    rig_sectors_min = rig_storage_min / sector_size
    rig_storage_parallelization_min = response_honest_min / polling_time
    rig_storage_unit_min = rig_storage_min / rig_storage_parallelization_min
    rig_storage_unit_min_tb = rig_storage_unit_min / (1024 * 1024 * 1024 * 1024)

  Honest:
    Encoding:
      encoding_window_time = (window_nodes * drg_parents) * hashing_time * drg_layers
      encoding_time = encoding_window_time * windows
      decoding_time = encoding_window_time
      
      encoding_time_parallel = encoding_time / rig_cores
      window_time_parallel = encoding_window_time / rig_cores

      Asic:
        encoding_time_parallel_asic = encoding_time_parallel / hashing_amax
        encoding_time_asic = encoding_time / hashing_amax
        encoding_window_time_asic = encoding_window_time / hashing_amax
        encoding_window_time_parallel_asic = encoding_window_time_parallel / hashing_amax

    Response:
      response_honest_min = challenges * challenged_sectors_percentage * rig_sectors_min * rig_storage_latency

    Throughput:
      // num_parallel_encoding = rig_ram_gb * rig_size / sector_size_gb
      // rig_cores = num_parallel_encoding
      // seal_throughput = (sector_size_gb * num_parallel_encoding) / encoding_time

    Vanilla:
      post_vanilla_size = node_size * (log2(nodes) + 1) * challenges

    SNARK:
      inclusion_proof = merkle_tree_hash_circuit * log2(nodes)
      inclusion_proofs = inclusion_proof * challenges
      ticket_proofs = ticket_circuit * challenges
      post_snark_constraints = ticket_proofs + inclusion_proofs
      post_snark_partitions = post_snark_constraints / max_snark_constraints
      post_snark_size = post_snark_partitions * snark_size
      post_snark_size_kb = post_snark_size / 1024

    Cost:
      Compute:
        nodes_per_second = hash_gb_per_second / node_hash_size_gb
        nodes_per_year = nodes_per_second * (60 * 60 * 24 * 365)
        cost_hash_node = rig_cost_per_year / nodes_per_year 

      Storage:
        cost_storage_gbs = cost_gb_per_month / secs_in_month 
        cost_storage_sector_polling_time = cost_storage_gbs * (sector_size_gb * (polling_time + extra_storage_time))


  Adversary:
    Rationality:
      describe(breakeven_nodes, "number of nodes / sector / challenge period after which it's cheaper to pay store the entire sector, than re-encode those")
      breakeven_nodes = ((cost_gb_per_month *  sector_size_gb) / (cost_hash_node * challenge_periods_per_month))
      regeneration_percentage = breakeven_nodes / nodes
