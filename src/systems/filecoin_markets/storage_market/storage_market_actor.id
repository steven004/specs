import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import deal "github.com/filecoin-project/specs/systems/filecoin_markets/deal"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"

type StorageParticipantBalance struct {
    Locked     actor.TokenAmount
    Available  actor.TokenAmount
}

type BalancesHAMT {addr.Address: StorageParticipantBalance}
type DealTallyAMT {deal.DealID: deal.StorageDealTally}
type DealAMT {deal.DealID: deal.StorageDeal}

type StorageMarketActorState struct {
    Balances               BalancesHAMT
    Deals                  DealAMT
    DealTally              DealTallyAMT
    DealStates             deal.DealStateSet
    DealCollateralSlashed  actor.TokenAmount

    _generateStorageDealID(rt Runtime, deal deal.StorageDeal) deal.DealID
    _isBalanceAvailable(a addr.Address, amount actor.TokenAmount) bool
    _assertDealStartAfterCurrEpoch(rt Runtime, p deal.StorageDealProposal)
    _assertDealNotYetExpired(rt Runtime, p deal.StorageDealProposal)
    _assertValidDealTimingAtPublish(rt Runtime, p deal.StorageDealProposal)
    _assertValidDealMinimum(rt Runtime, p deal.StorageDealProposal)
    _assertSufficientBalanceAvailForDeal(rt Runtime, p deal.StorageDealProposal)
    _assertDealExpireAfterMaxProveCommitWindow(rt Runtime, p deal.StorageDealProposal)

    // check if StorageDeal is signed before expiry
    // check if StorageDeal has the right signatures
    // check if minimum StoragePrice and StorageCollateral are met
    // check if provider and client have sufficient balances
    _validateNewStorageDeal(rt Runtime, deal deal.StorageDeal) bool

    _lockBalance(rt Runtime, addr addr.Address, amount actor.TokenAmount)
    _unlockBalance(rt Runtime, addr addr.Address, amount actor.TokenAmount)
    _transferBalance(
        rt           Runtime
        fromLocked   addr.Address
        toAvailable  addr.Address
        amount       actor.TokenAmount
    )
    _lockFundsForStorageDeal(rt Runtime, deal deal.StorageDeal)

    _getDeal(rt Runtime, dealID deal.DealID) deal.StorageDeal
    _getDealTally(rt Runtime, dealID deal.DealID) deal.StorageDealTally
    _assertPublishedDealState(rt Runtime, dealID deal.DealID)
    _assertActiveDealState(rt Runtime, dealID deal.DealID)

    _expireStorageDeals(
        rt                     Runtime
        dealIDs                [deal.DealID]
        lastChallengeEndEpoch  block.ChainEpoch
    )
    _creditUnlockedFeeForProvider(
        rt         Runtime
        dealP      deal.StorageDealProposal
        dealTally  deal.StorageDealTally
    )
    _tallyStorageDeals(
        rt                     Runtime
        dealIDs                [deal.DealID]
        lastChallengeEndEpoch  block.ChainEpoch
    )

    _slashTerminatedFaults(rt Runtime, dealIDs [deal.DealID])
    _terminateDeal(rt Runtime, dealID deal.DealID)
    _slashDealCollateral(
        rt         Runtime
        dealTally  deal.StorageDealTally
        amount     actor.TokenAmount
    )
}

type StorageMarketActorCode struct {
    WithdrawBalance(rt Runtime, balance actor.TokenAmount)
    AddBalance(rt Runtime)  // amount is in the message

    // call by StorageMiningSubsystem before PreCommitSector
    // a StorageDeal is only published on chain when it passes _validateNewStorageDeal
    // _validateNewStorageDeal checks for the following:
    //     - deal did not start/expire when it is signed
    //     - deal hits the chain before its StartEpoch
    //     - client and provider address and signature are correct (TODO may be unnecessary)
    //     - client and provider have sufficient balances to lock up
    // a DealID will be assigned and stored in the mapping of DealID to StorageDeal
    // _lockBalance is then called after each _validateNewStorageDeal to lock up balances
    PublishStorageDeals(rt Runtime, deals [deal.StorageDeal]) [PublishStorageDealResponse]

    // Call by sm.PreCommitSector
    // Verify the following:
    //     - dealIDs have been registered in PublishedDeals
    //     - deals will not expire by the time ProveCommit hits
    //     - deals have not started
    // Fail PreCommit if any of above is not true and abort
    VerifyPublishedDealIDs(rt Runtime, dealIDs [deal.DealID])

    // Call by sm.ProveCommitSector
    // Verify the following:
    //     - dealIDs are in PublishedDeals
    //     - deals have not expired, OK if deals have started
    // Fail ProveCommit if any of the above is not true and abort
    // Move deals from PublishDeals to ActiveDeals if all deals satisfy the requirement
    ActivateDeals(rt Runtime, dealIDs [deal.DealID])

    // call by sm.ProveCommitSector to get deals in a Sector
    GetDeals(rt Runtime, dealIDs [deal.DealID]) [deal.StorageDeal]

    // call by StorageMinerActor
    // slash deal collateral depending on the faults (only TerminatedFault)
    ProcessDealSlash(rt Runtime, info deal.BatchDealSlashInfo)

    // call by StorageMinerActor
    // unlock balances in UnlockedFees in dealTally
    CreditUnlockedFees(rt Runtime, dealIDs [deal.DealID])

    // batch process storage deal payment based on actions
    //     - Credit: lazily evaulated when a StorageMiner calls CreditDealPayment
    //     - Expire: call by sm._submitPowerReport when deals expire
    // Note: if a sector enters into a Failing state but later recovers, client still pays miner as usual
    // client only stops paying when a sector gets cleared (expired or faulted)
    // Deal expiration is also handled here
    ProcessDealPayment(rt Runtime, info deal.BatchDealPaymentInfo)

    GetPieceInfosForDealIDs(rt Runtime, dealIDs [deal.DealID]) [sector.PieceInfo]
}
