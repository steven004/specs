import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import deal "github.com/filecoin-project/specs/systems/filecoin_markets/deal"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"

type StorageParticipantBalance struct {
    Locked     actor.TokenAmount
    Available  actor.TokenAmount
}

type BalancesHAMT {addr.Address: StorageParticipantBalance}
type PublishedDealsAMT {deal.DealID: deal.StorageDeal}
type ActiveDealsAMT {deal.DealID: deal.ActiveStorageDeal}

type StorageMarketActorState struct {
    Balances        BalancesHAMT
    PublishedDeals  PublishedDealsAMT
    ActiveDeals     ActiveDealsAMT

    // generate storage deal id
    _generateStorageDealID(rt Runtime, deal deal.StorageDeal) deal.DealID

    // check if StorageDeal is signed before expiry
    // check if StorageDeal has the right signatures
    // check if minimum StoragePrice and StorageCollateral are met
    // check if provider and client have sufficient balances
    _validateNewStorageDeal(rt Runtime, deal deal.StorageDeal) bool

    _lockFundsForStorageDeal(rt Runtime, deal deal.StorageDeal)

    _expireStorageDeals(
        rt                     Runtime
        dealIDs                [deal.DealID]
        lastChallengeEndEpoch  block.ChainEpoch
    )
    _creditStorageDeals(
        rt                     Runtime
        dealIDs                [deal.DealID]
        lastChallengeEndEpoch  block.ChainEpoch
    )

    _slashDeclaredFaults(rt Runtime, dealIDs [deal.DealID])
    _slashDetectedFaults(rt Runtime, dealIDs [deal.DealID])
    _slashTerminatedFaults(rt Runtime, dealIDs [deal.DealID])

    _lockBalance(rt Runtime, addr addr.Address, amount actor.TokenAmount)
    _unlockBalance(rt Runtime, addr addr.Address, amount actor.TokenAmount)
    _transferBalance(
        rt           Runtime
        fromLocked   addr.Address
        toAvailable  addr.Address
        amount       actor.TokenAmount
    )
    _isBalanceAvailable(a addr.Address, amount actor.TokenAmount) bool
}

type StorageMarketActorCode struct {
    WithdrawBalance(rt Runtime, balance actor.TokenAmount)
    AddBalance(rt Runtime)  // amount is in the message

    // call by StorageMiningSubsystem before PreCommitSector
    // a StorageDeal is only published on chain when it passes _validateNewStorageDeal
    // _validateNewStorageDeal checks for the following:
    //     - deal did not start/expire when it is signed
    //     - deal hits the chain before its StartEpoch
    //     - client and provider address and signature are correct (TODO may be unnecessary)
    //     - client and provider have sufficient balances to lock up
    // a DealID will be assigned and stored in the mapping of DealID to StorageDeal
    // _lockBalance is then called after each _validateNewStorageDeal to lock up balances
    PublishStorageDeals(rt Runtime, deals [deal.StorageDeal]) [PublishStorageDealResponse]

    // Call by sm.PreCommitSector
    // Verify the following:
    //     - dealIDs have been registered in PublishedDeals
    //     - deals will not expire by the time ProveCommit hits
    //     - deals have not started
    // Fail PreCommit if any of the above is not true and abort
    VerifyPublishedDealIDs(rt Runtime, dealIDs [deal.DealID]) bool

    // Call by sm.ProveCommitSector
    // Verify the following:
    //     - dealIDs are in PublishedDeals
    //     - deals have not expired, OK if deals have started
    // Fail ProveCommit if any of the above is not true and abort
    // Move deals from PublishDeals to ActiveDeals if all deals satisfy the requirement
    ActivateSectorDealIDs(rt Runtime, dealIDs [deal.DealID]) bool

    // call by sm.ProveCommitSector
    // get InitialUtilization for deals in a Sector
    GetInitialUtilizationInfo(rt Runtime, dealIDs [deal.DealID]) sector.SectorUtilizationInfo

    // batch process storage deal payment based on actions
    //     - Credit: lazily evaulated when a StorageMiner calls ProcessSectorDealPayment
    //     - Expire: call by sm._submitPowerReport when deals expire
    // Note: if a sector enters into a Failing state but later recovers, client still pays miner as usual
    // client only stops paying when a sector gets cleared (expired or faulted)
    // Deal expiration is also handled here
    ProcessSectorDealPayment(rt Runtime, info deal.BatchDealPaymentInfo)

    // TODO: StorageDeals should be renewable
    // UpdateStorageDeal(newStorageDeals [deal.StorageDeal])

    GetPieceInfosForDealIDs(rt Runtime, dealIDs [deal.DealID]) [sector.PieceInfo]

    // call by StorageMinerActor
    // slash deal collateral depending on the faults
    ProcessSectorDealSlash(rt Runtime, info deal.BatchDealSlashInfo)
}
